const keys = {
  // "Any response"
  Any: 0,
  // general
  Informational: 1,
  Success: 2,
  Redirect: 3,
  Error: 45,
  ClientError: 4,
  ServerError: 5,
  // 1××
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  // 2××
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  IMUsed: 226,
  // 3××
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  SwitchProxy: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  // 4××
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  URITooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  // 5××
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HTTPVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
function stringifyQuery(api) {
  for (const key of Object.keys(api.query)) {
    if (typeof api.query[key] === "object")
      api.query[key] = JSON.stringify(api.query[key]);
  }
}
function setBody(options, api) {
  if (options.config.sendEmptyBodyAsJSON === false)
    return;
  if (api.method === "GET" || api.method === "HEAD")
    return;
  api.body = "body" in api ? typeof api.body === "object" && JSON.stringify(api.body) : "{}";
}
function handler(options, api) {
  const { fetch: fetch2 } = options;
  const stringifyQueryObjects = options.config.stringifyQueryObjects === void 0 ? true : options.config.stringifyQueryObjects;
  if (stringifyQueryObjects && "query" in api)
    stringifyQuery(api);
  const url = (options.config.baseUrl || "") + options.path + ("query" in api ? "?" + new URLSearchParams(api.query).toString() : "");
  const baseData = options.config.baseData || {};
  const isForm = Object.prototype.toString.call(api.body) === "[object FormData]";
  if (!("content-type" in api.headers))
    api.headers["content-type"] = api.headers["content-type"] || isForm ? "multipart/form-data" : "application/json";
  setBody(options, api);
  if (api.method === "GET" && !("cache-control" in api.headers))
    api.headers["cache-control"] = "public, max-age=604800, immutable";
  api.headers["x-requested-with"] = "sveltekit-zero-api";
  const callbacks = [];
  const $ = {
    callback: void 0,
    promise: void 0,
    resolve: void 0
  };
  let resolver;
  let promiser = new Promise((resolve) => resolver = resolve);
  let fetchAPI = {
    ...callbackHandler((s, cb) => {
      callbacks.push([s, cb]);
      return proxy;
    }),
    ...promiser
  };
  fetchAPI["_"] = fetchAPI;
  fetchAPI["$"] = callbackHandler((s, cb) => {
    $.callback = [s, cb];
    $.promise = new Promise((resolve) => $.resolve = resolve);
    $.promise.then((d) => resolver(d));
    return promiser;
  });
  const requestInit = { ...baseData, ...api, headers: { ...baseData["headers"] || {}, ...api["headers"] || {} } };
  if (api.body === void 0)
    delete requestInit["body"];
  const collapsedRequestInit = api.method === "GET" ? void 0 : requestInit;
  const response = fetch2(url, collapsedRequestInit);
  response.then(async (res) => {
    const json = (res.headers.get("content-type") || "").includes("application/json") && await res[options.config.format || "json"]();
    const response2 = {
      body: json || res.body,
      bodyUsed: res.bodyUsed,
      clone: res.clone,
      headers: res.headers,
      ok: res.ok,
      redirected: res.redirected,
      status: res.status,
      statusText: res.statusText,
      type: res.type,
      url: res.url
    };
    if (!res.bodyUsed) {
      response2.blob = res.blob;
      response2.arrayBuffer = res.arrayBuffer;
      response2.formData = res.formData;
      response2.text = res.text;
      response2.json = res.json;
    }
    respond(callbacks, response2, options, $);
    if (!$.promise)
      resolver(response2);
  });
  response.catch((err) => {
    if ("onError" in options.config)
      options.config.onError && options.config.onError(err);
    throw err;
  });
  const proxy = new Proxy(fetchAPI, {
    get(target, prop) {
      if (prop === "then")
        return promiser.then.bind(promiser);
      if (prop === "catch")
        return promiser.catch.bind(promiser);
      if (prop === "finally")
        return promiser.finally.bind(promiser);
      return target[prop];
    }
  });
  return proxy;
}
function respond(callbacks, res, options, $) {
  let statusRange = Math.floor(res.status / 100);
  let responseError = statusRange === 4 || statusRange === 5;
  const validStatus = (code) => code === 0 || code === statusRange || code === res.status || responseError && code === 45;
  const { prependCallbacks } = options.config;
  if (prependCallbacks) {
    let cbs = [];
    let prepender = callbackHandler((s, cb) => {
      cbs.push([s, cb]);
      return prepender;
    });
    prependCallbacks(prepender);
    callbacks = [...cbs, ...callbacks];
  }
  callbacks.filter(([code]) => validStatus(code)).forEach(([code, cb]) => {
    cb(res);
  });
  if ($.resolve && $.callback) {
    if (validStatus($.callback[0]))
      $.resolve($.callback[1](res));
    else
      $.resolve(void 0);
  }
  if ("onSuccess" in options.config)
    options.config.onSuccess && options.config.onSuccess(res);
}
function callbackHandler(handleCallback) {
  return Object.entries(keys).reduce((previous, [key, val]) => ({ ...previous, [key]: function(cb) {
    return handleCallback(val, cb);
  } }), {});
}
const endpoints = [
  "GET",
  "POST",
  "PUT",
  "PATCH",
  "DELETE",
  "OPTIONS"
];
const apiKeys = Object.keys(keys).reduce((previous, current) => ({ ...previous, [current]: (...args) => emptyProxy }), {});
const emptyProxy = new Proxy({}, {
  get: function(target, prop) {
    if (prop === "$" || prop === "_")
      return emptyProxy;
    let k = apiKeys[prop];
    if (k)
      return k;
    return target[prop];
  }
});
function createZeroApi(config) {
  function createDirectory(directory) {
    let route = "";
    function handleDirectory() {
      const isSlug = route.match(/\$$/g);
      if (isSlug)
        return function sluggedRoute(slug) {
          return createDirectory({ path: directory.path + "/" + slug });
        };
      directory[route] = createDirectory({ path: directory.path + "/" + route });
      return directory[route];
    }
    function handleEndpoint() {
      const method = route.toUpperCase();
      const path = directory.path;
      directory[route] = (contents, _fetch = null) => {
        if (_fetch == null && typeof document === "undefined")
          return emptyProxy;
        return handler({ config, path, fetch: _fetch || fetch }, { method, headers: {}, ...contents });
      };
      return directory[route];
    }
    return new Proxy(directory, {
      get(directory2, _route) {
        route = _route;
        if (directory2[route])
          return directory2[route];
        if (endpoints.includes(route))
          return handleEndpoint();
        return handleDirectory();
      }
    });
  }
  return createDirectory({ path: "" });
}
const routes = createZeroApi({
  baseUrl: "https://youtube-browser-api.netlify.app",
  onError: async (err) => console.error("[youtube-browser-api]", err),
  prependCallbacks(method) {
    method.Error((err) => {
      console.warn("Error", err);
    });
  }
});
export {
  routes as default
};
